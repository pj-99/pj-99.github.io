{"/about/":{"data":{"":"","#":"About me I like milk tea.\nSome experience developing Android apps and Unity games Currently learning Go Education Master’s in Computer Science, National Chengchi University (2023 - Present)\nMember of NCCU Software Engineering Lab Bachelor’s in Interdisciplinary Program of Technology and Art, National Tsing Hua University (2019 - 2023)\nMember of NTHU Ubicomp Lab Experience Shopback software engineer intern, mobile platform team (2022.6 - 2023.6) Featured Projects 習慣城自然：當代人類行為百科 The Story of a Nostalgic Town - AR App This work presents through an installation, based on a landscape model of a town, accompanied by a dedicated app. Audiences can use augmented reality (AR) to view fragments of stories within the model, piecing together the narratives of the town and the residents.\nAn interactive installation art work with an AR App for the graduation exhibition. Tech stack used: Unity, C#, Vuforia, Figma, Firebase, Raspberry Pi, Python 放視大賞 2023 決選入圍 Watch video✨ Online exhibition TechLifeProbe - Android App A system to probe how data sharing with adolescents’ parents improves their technology abuse through mobile phones\nDeveloped an Android app for human-computer interaction research aimed at improving technology abuse. This research was published in ACM CHI 2022.\nTech stack used: Android, Kotlin, MySQL, PHP, Figma, Python\nRelated publication\nUsing Mobile and Wearable Technologies to Improve Adolescents’ Smartphone Addiction through the Sharing of Personal Data with Parents. Pin-Chieh Chen, Min-Wei Hung, Hsueh-Sung Lu, Chien Wen (Tina) Yuan, Nanyi Bi, Wan-Chen Lee, Ming-Chyi Huang, Chuang-Wen You - ACM CHI, 2022 Project Gallery 習慣城自然：當代人類行為百科 | ARAn interactive installation art work with an AR App for the tech art grduation exhibition. TechLifeProbe Android AppAn Android App for sharing data between tech abuse adolescents and their parents. "},"title":"Hi, I'm PJ."},"/blog/":{"data":{"":"一些筆記📓"},"title":"Blog"},"/blog/aws/lambda/lambda_access_internet_and_vpc/":{"data":{"":"Lambda 的網路能力可以分為兩種，有連接到 VPC 或沒有。\n最近做專案時，想嘗試用 Lambda 將第三方 API 回傳的資料存入 VPC 內的 RDS，但在過程中發現，在預設（沒有特別設定 NAT 等、沒有什麼預算）的情況下，無法直接讓一個 Lambda 同時存取外網服務又存取 VPC，經過一番掙扎，最後透過「將事情分給不同 Lambda 還有用 Lambda destination 傳資料」來解決這個問題。\n這篇會先簡單介紹 AWS Lambda 的網路能力，再介紹 Lambda 存取外網和 VPC 的一種方法。","aws-lambda-如何存取外網和-vpc#AWS Lambda 如何存取外網和 VPC":"那麼沒有預算可以開 NAT 的情況下，該怎麼做才能讓 Lambda 可以存取外網、又存取 VPC 呢？\nGoogle 了一陣子，從一位大大分享的 AWS Lambda 做網路爬蟲的文章認識到 Lambda destination 可以用來傳遞 Lambda 之間的資料，也看到可以將 Lambda 打外網的結果存在 s3 上，再用另一個 Lambda 從 s3 讀檔做進一步處理。\n從這流程學到一種做法是：不要只侷限一個 Lambda，中間的資料傳過去就好。美其名還可以視作「解耦 Lambda」😼\n回到要將外網資料存回 RDS 的目標，我將「存取網路資料」與「寫入 DB 」分開：存取外網的事給 no-VPC 的 Lambda 做，寫 DB 的事就給 VPC 的 Lambda 做，也用 s3 來儲存中間產物。\n但跟上面文章不一樣的是，我不是設定 s3 會 trigger 第二個 Lambda，而是讓第一個 Lambda 透過 Lambda destination 觸發第二個 Lambda，第二個 Lambda 再主動從 s3 下載檔案。\n這樣的做法需要額外設定 VPC 的 s3 gateway endpoint，讓 VPC 的網路流量不用經過外網再到 s3，而是透過 gateway endpoint 直接傳到 s3。\ns3 和 dynamo DB 是 AWS 服務中少數可以免費在 VPC 中使用 gateway endpoint 的服務。 整體流程如下圖，想不太起來自己為什麼這樣做而不是像上面文章直接從 s3 trigger\n總之這個流程是可以正常運作的，但是後來考量到我們專案的需求，這條流程每 10 分鐘就會被觸發一次，一個月就會 PUT 4300 多次，因此這樣會用光免費方案提供的一個月 2000 次的 PUT，不是個適合沒有什麼預算的方法。\n於是經過研究，又調整了一下流程，直接用 Lambda destination 這個功能來傳中間產物。","aws-lambda-的網路能力-attach-vpc-or-no-vpc#AWS Lambda 的網路能力: attach-VPC or no-VPC":"在設定 Lambda 時，有個選項是 Enable VPC，打開之後就可以選要讓 Lambda 連接到哪個 VPC，透過這個設定就能讓 Lambda 存取到 VPC 內的資源。 一開始在趕著實作出專案功能時，還以為把這個 Enable VPC 勾勾起來，就像是把 Lambda 放在 VPC 內，後來看到官方資料與其他大大的整理，才發現其實背後發生的事情並不是想像的這樣，能夠存取 VPC 的 Lambda 沒有真的放在 VPC 內，而是它可以連接到 VPC (attach-VPC)。\n以下使用的示意圖來源為 AWS re:Invent 2020 AWS Lambda networking best practices，裡面有許多關於 Lambda networking 詳盡且附圖的介紹，推推。\n首先需要知道的背景知識是，所有的 Lambda 都被放在 AWS 管理的 Lambda service VPC 中執行，呼叫 Lambda 都是統一透過 Lambda service API： 而 Lambda 的網路連線能力分為兩種，如下面這張圖的 no-VPC 或是連接 VPC。\n預設的 no-VPC 模式讓 Lambda 可以存取網際網路上的東西，不能存取 VPC 的資源（畢竟是 Virtual private cloud）。\n而將 Enable VPC 模式打勾後，Lambda 還是會被放在 Lambda service VPC 裡，但是這個 Lambda 的所有網路流量都會被導到選擇的 VPC，也因此如果 VPC 沒有特別設定（像是 NAT 等等），那麼這個 Lambda 是不能跟外網資源溝通的。\n中間發生了什麼事情可以看 AWS Lambda networking best practices 的詳盡介紹 ","lambda-destination-將-lambda-結果傳下去#Lambda destination: 將 Lambda 結果傳下去":"Lambda destination 可以將 Lambda 的執行結果傳遞給另一個服務，還可以設定當成功再傳或是失敗時再傳，目前可以傳遞的目標服務包含：SNS, SQS, Lambda, EventBridge。\n舉例來說，你可以設定某個要監控的 A Lambda 有一條 on Failure 的 destination 到另一個通知用的 Lambda，若 A Lambda 某天執行失敗，就會將失敗的結果傳遞給會發通知的 Lambda。\n但使用 Lambda destination 時要注意：\nLambda 的呼叫方式有分 sync 和 async，可以用「需不需要立刻得到回傳值」來判斷是哪種，只有 async 呼叫方式會觸發 lambda destination，所觸發的另一個 lambda 也是 async 呼叫。 例如，在 AWS console 用 test 戳它是 sync，所以不會觸發 lambda destination。被 EventBridge 的 event 觸發則是 async。 詳細可以參考這群大大的整理: lambda-destinations-what-we-learned-the-hard-way 如果目標服務是另一個 Lambda，那 payload 就會受限於 Lambda async invocation payload 的限制，payload 上限只有 256 KB。 為了讓 payload 不要太大，可以壓縮資料。\n像是我們專案使用了 gzip 來壓縮，例如原本的 JSON 是 279 KB ，透過 gzip 壓縮，可以降低到 19 KB。\n最終實作的流程其實很簡單，如下圖：no-VPC Lambda 先打外網，將資料壓縮並回傳，再透過 Lambda destination 將資料傳遞給 VPC Lambda，最後再與 VPC 內的資源溝通。","references#References":" https://d1.awsstatic.com/events/reinvent/2020/AWS_Lambda_networking_best_practices_SVS312.pdf https://stackoverflow.com/questions/52992085/why-cant-an-aws-lambda-function-inside-a-public-subnet-in-a-vpc-connect-to-the https://medium.com/@arunasilva86/how-to-use-vpc-networking-effectively-for-lambda-445abefdf8cf https://aws.amazon.com/tw/blogs/compute/announcing-improved-vpc-networking-for-aws-lambda-functions/ https://aws.amazon.com/tw/blogs/compute/using-aws-lambda-iam-condition-keys-for-vpc-settings/ https://3lexw.medium.com/aws-%E6%9C%AD%E8%A8%98-3-%E5%88%A9%E7%94%A8-aws-s3-%E4%BD%9C%E7%82%BA-aws-lambda-%E5%87%BD%E6%95%B8%E4%B9%8B%E9%96%93%E7%9A%84%E4%B8%AD%E8%BD%89%E7%AB%99-982d40e6e20f ","小結#小結":"網路上還有許多關於這個問題的豐富討論與方法比較，這篇提到的只是其中一種做法，像是如果你要存取外網只是為了用 AWS 本身服務的話，那很高機率會有其他更適合的方法。\n但如果你的需求和這篇描述的情境類似，是 async 觸發的、要存取第三方服務、資料不大，那拆分成兩個 Lambda 並透過 destination 傳遞或許是個簡單的選擇。"},"title":"AWS Lambda 的網路能力和 Lambda 如何存取外網和 VPC"},"/blog/git/merge_two_repos/":{"data":{"":"","example#Example":" # Go to your new project folder and init git echo \"# my_project\" \u003e\u003e README.md git init # You must have one commit to use git subtree add git add README.md git commit -m \"first commit\" # For example, put the backend repo into the backend folder git subtree add -P backend https://github.com/path_to_backend.git main # And frontend folder git subtree add -P frontend https://github.com/path_to_frontend.git main ","git-subtree-add#git subtree add":" git subtree add -P \u003cprefix\u003e add \u003crepository\u003e \u003cremote-ref\u003e \u003cprefix\u003e: 要放在哪個 subdirectory \u003crepository\u003e: repository link \u003cremote-ref\u003e: branch ","how-to-merge-two-repositories-into-one#How to merge two repositories into one":"例如你已經開發一個 web 一段時間，有一個 backend 的 repo 和一個 frontend 的 repo，現在想要將它們合併成一個 repo，又不想完全失去之前的歷史記錄，就可以用 git subtree add 加入指定 repo 的 commit tree。","ref#Ref":" https://stackoverflow.com/a/32684526/19055115 git subtree 除了 add 還有 merge 、split 等等各種進階的用法 "},"title":"Git - How to merge two repositories into one using git subtree add"},"/blog/go/go_channels/":{"data":{"":"","channel#Channel":"Channel 是個 typed 的管道，go 程式可以透過 channel operator \u003c- 去接受或發送某個值。透過 channel 可以同步不同的 Goroutine。\n箭頭的方向就代表了資料的傳輸方向：\nch := make(chan int) // create a channel for int v := 100 go func() { fmt.Println(\"Sending v to channel\") ch \u003c- v // Send value to the channel }() recv := \u003c- ch // Get value from the channel fmt.Printf(\"recv: %v\", recv) 預設情況下，接受與發送都會 block 住，直到另一端也發送或接受，像是以下的程式會停在 ch \u003c- v，因為程式還在等人發送值到 channel 中，會出現 deadlock 錯誤 fatal error: all goroutines are asleep - deadlock!：\nch := make(chan int) // create a channel for int v := 100 fmt.Println(\"Sending v to channel\") ch \u003c- v // The code will stop here and wait for the value... recv := \u003c- ch fmt.Printf(\"recv: %v\", recv) channel 的 block 行為是可以被控制的，channel 可以宣告成 buffered channel，一個 buffered channel 裡的值可以保存起來，接受端只要拿的到值就可以繼續，發送端只要發送值進去後 channel 沒有超過容量也可以繼續。\nbuffered channel 的容量透過 make() 的第二個參數指定：\nch := make(chan int, 1) 將上面會造成 deadlock 的 channel 改成 buffered channel (size = 1) ，就可以正常執行了：\nch := make(chan int, 1) // create a buffered channel for int v := 100 fmt.Println(\"Sending v to channel\") ch \u003c- v recv := \u003c- ch fmt.Printf(\"recv: %v\", recv) Close the channel Sender 可以透過 close(channel) 通知 receiver 之後不會傳東西到這個 channel 中了。 Receiver 可以透過 v, ok := \u003c- ch 的 ok 是 false 得知 channel 已被關閉，也可以透過 for i := range c 接受值，直到 channel 被關閉。 ","refs#Refs":" A Tour of Go Go 语言 select 的实现原理 | Go 语言设计与实现 (draveness.me) ","select#Select":" select 可以從多個 case 中執行符合的操作。 如果同時有多個條件都符合，隨機選一個。 select （在沒有定義 default 時），會 block 並等待某個 case 並執行對應的操作： select 加上 default 後就不會 block，因為當其他 channel 都還沒好時，會進到 default 中，見官方範例參考： tick := time.Tick(100 * time.Millisecond) boom := time.After(500 * time.Millisecond) for { select { case \u003c-tick: fmt.Println(\"tick.\") case \u003c-boom: fmt.Println(\"BOOM!\") return default: fmt.Println(\" .\") time.Sleep(50 * time.Millisecond) } } "},"title":"Go - Channels"},"/projects/":{"data":{"":" Chiikawa manga finder(WIP)Find and read Chiikawa manga easily 習慣城自然：當代人類行為百科 | ARInteractive installation art work with AR App "},"title":"Projects"}}