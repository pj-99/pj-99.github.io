{"/about/":{"data":{"":"","#":"About me I like milk tea.\nSome experience developing Android apps and Unity games Currently learning Go Education Master’s in Computer Science, National Chengchi University (2023 - Present)\nMember of NCCU Software Engineering Lab Bachelor’s in Interdisciplinary Program of Technology and Art, National Tsing Hua University (2019 - 2023)\nMember of NTHU Ubicomp Lab Experience Shopback software engineer intern, mobile platform team (2022.6 - 2023.6) Featured Projects 習慣城自然：當代人類行為百科 The Story of a Nostalgic Town - AR App This work presents through an installation, based on a landscape model of a town, accompanied by a dedicated app. Audiences can use augmented reality (AR) to view fragments of stories within the model, piecing together the narratives of the town and the residents.\nAn interactive installation art work with an AR App for the graduation exhibition. Tech stack used: Unity, C#, Vuforia, Figma, Firebase, Raspberry Pi, Python 放視大賞 2023 決選入圍 Watch video✨ Online exhibition TechLifeProbe - Android App A system to probe how data sharing with adolescents’ parents improves their technology abuse through mobile phones\nDeveloped an Android app for human-computer interaction research aimed at improving technology abuse. This research was published in ACM CHI 2022.\nTech stack used: Android, Kotlin, MySQL, PHP, Figma, Python\nRelated publication\nUsing Mobile and Wearable Technologies to Improve Adolescents’ Smartphone Addiction through the Sharing of Personal Data with Parents. Pin-Chieh Chen, Min-Wei Hung, Hsueh-Sung Lu, Chien Wen (Tina) Yuan, Nanyi Bi, Wan-Chen Lee, Ming-Chyi Huang, Chuang-Wen You - ACM CHI, 2022 Project Gallery 習慣城自然：當代人類行為百科 | ARAn interactive installation art work with an AR App for the tech art grduation exhibition. TechLifeProbe Android AppAn Android App for sharing data between tech abuse adolescents and their parents. "},"title":"Hi, I'm PJ."},"/blog/":{"data":{"":"一些筆記📓"},"title":"Blog"},"/blog/git/merge_two_repos/":{"data":{"":"","example#Example":" # Go to your new project folder and init git echo \"# my_project\" \u003e\u003e README.md git init # You must have one commit to use git subtree add git add README.md git commit -m \"first commit\" # For example, put the backend repo into the backend folder git subtree add -P backend https://github.com/path_to_backend.git main # And frontend folder git subtree add -P frontend https://github.com/path_to_frontend.git main ","git-subtree-add#git subtree add":" git subtree add -P \u003cprefix\u003e add \u003crepository\u003e \u003cremote-ref\u003e \u003cprefix\u003e: 要放在哪個 subdirectory \u003crepository\u003e: repository link \u003cremote-ref\u003e: branch ","how-to-merge-two-repositories-into-one#How to merge two repositories into one":"例如你已經開發一個 web 一段時間，有一個 backend 的 repo 和一個 frontend 的 repo，現在想要將它們合併成一個 repo，又不想完全失去之前的歷史記錄，就可以用 git subtree add 加入指定 repo 的 commit tree。","ref#Ref":" https://stackoverflow.com/a/32684526/19055115 git subtree 除了 add 還有 merge 、split 等等各種進階的用法 "},"title":"Git - How to merge two repositories into one using git subtree add"},"/blog/go/go_channels/":{"data":{"":"","channel#Channel":"Channel 是個 typed 的管道，go 程式可以透過 channel operator \u003c- 去接受或發送某個值。透過 channel 可以同步不同的 Goroutine。\n箭頭的方向就代表了資料的傳輸方向：\nch := make(chan int) // create a channel for int v := 100 go func() { fmt.Println(\"Sending v to channel\") ch \u003c- v // Send value to the channel }() recv := \u003c- ch // Get value from the channel fmt.Printf(\"recv: %v\", recv) 預設情況下，接受與發送都會 block 住，直到另一端也發送或接受，像是以下的程式會停在 ch \u003c- v，因為程式還在等人發送值到 channel 中，會出現 deadlock 錯誤 fatal error: all goroutines are asleep - deadlock!：\nch := make(chan int) // create a channel for int v := 100 fmt.Println(\"Sending v to channel\") ch \u003c- v // The code will stop here and wait for the value... recv := \u003c- ch fmt.Printf(\"recv: %v\", recv) channel 的 block 行為是可以被控制的，channel 可以宣告成 buffered channel，一個 buffered channel 裡的值可以保存起來，接受端只要拿的到值就可以繼續，發送端只要發送值進去後 channel 沒有超過容量也可以繼續。\nbuffered channel 的容量透過 make() 的第二個參數指定：\nch := make(chan int, 1) 將上面會造成 deadlock 的 channel 改成 buffered channel (size = 1) ，就可以正常執行了：\nch := make(chan int, 1) // create a buffered channel for int v := 100 fmt.Println(\"Sending v to channel\") ch \u003c- v recv := \u003c- ch fmt.Printf(\"recv: %v\", recv) Close the channel Sender 可以透過 close(channel) 通知 receiver 之後不會傳東西到這個 channel 中了。 Receiver 可以透過 v, ok := \u003c- ch 的 ok 是 false 得知 channel 已被關閉，也可以透過 for i := range c 接受值，直到 channel 被關閉。 ","refs#Refs":" A Tour of Go Go 语言 select 的实现原理 | Go 语言设计与实现 (draveness.me) ","select#Select":" select 可以從多個 case 中執行符合的操作。 如果同時有多個條件都符合，隨機選一個。 select （在沒有定義 default 時），會 block 並等待某個 case 並執行對應的操作： select 加上 default 後就不會 block，因為當其他 channel 都還沒好時，會進到 default 中，見官方範例參考： tick := time.Tick(100 * time.Millisecond) boom := time.After(500 * time.Millisecond) for { select { case \u003c-tick: fmt.Println(\"tick.\") case \u003c-boom: fmt.Println(\"BOOM!\") return default: fmt.Println(\" .\") time.Sleep(50 * time.Millisecond) } } "},"title":"Go - Channels"}}